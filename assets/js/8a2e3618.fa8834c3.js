"use strict";(self.webpackChunkokai_docs=self.webpackChunkokai_docs||[]).push([[71285],{52384:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"advanced/autonomous-trading","title":"\ud83d\udcc8 Autonomous Trading","description":"Overview","source":"@site/docs/advanced/autonomous-trading.md","sourceDirName":"advanced","slug":"/advanced/autonomous-trading","permalink":"/okai/docs/advanced/autonomous-trading","draft":false,"unlisted":false,"editUrl":"https://github.com/okcashpro/okai/tree/main/docs/docs/advanced/autonomous-trading.md","tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_position":16},"sidebar":"tutorialSidebar","previous":{"title":"Trust Engine","permalink":"/okai/docs/advanced/trust-engine"},"next":{"title":"OKai in TEE","permalink":"/okai/docs/advanced/okai-in-tee"}}');var a=r(74848),i=r(28453);const o={sidebar_position:16},s="\ud83d\udcc8 Autonomous Trading",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Core Components",id:"core-components",level:2},{value:"Token Provider",id:"token-provider",level:3},{value:"Swap Execution",id:"swap-execution",level:3},{value:"Position Management",id:"position-management",level:2},{value:"Order Book System",id:"order-book-system",level:3},{value:"Position Sizing",id:"position-sizing",level:3},{value:"Risk Management",id:"risk-management",level:2},{value:"Token Validation",id:"token-validation",level:3},{value:"Trade Management",id:"trade-management",level:3},{value:"Market Analysis",id:"market-analysis",level:2},{value:"Price Data Collection",id:"price-data-collection",level:3},{value:"Technical Analysis",id:"technical-analysis",level:3},{value:"Trade Execution",id:"trade-execution",level:2},{value:"Swap Implementation",id:"swap-implementation",level:3},{value:"DAO Integration",id:"dao-integration",level:3},{value:"Monitoring &amp; Safety",id:"monitoring--safety",level:2},{value:"Health Checks",id:"health-checks",level:3},{value:"Safety Limits",id:"safety-limits",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Transaction Errors",id:"transaction-errors",level:3},{value:"Recovery Procedures",id:"recovery-procedures",level:3}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"-autonomous-trading",children:"\ud83d\udcc8 Autonomous Trading"})}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"OKai's autonomous trading system enables automated token trading on the Solana blockchain. The system integrates with Jupiter aggregator for efficient swaps, implements smart order routing, and includes risk management features."}),"\n",(0,a.jsx)(e.h2,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsx)(e.h3,{id:"token-provider",children:"Token Provider"}),"\n",(0,a.jsx)(e.p,{children:"Manages token information and market data:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'class TokenProvider {\r\n  constructor(\r\n    private tokenAddress: string,\r\n    private walletProvider: WalletProvider,\r\n  ) {\r\n    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache\r\n  }\r\n\r\n  async fetchPrices(): Promise<Prices> {\r\n    const { SOL, BTC, ETH } = TOKEN_ADDRESSES;\r\n    // Fetch current prices\r\n    return {\r\n      solana: { usd: "0" },\r\n      bitcoin: { usd: "0" },\r\n      ethereum: { usd: "0" },\r\n    };\r\n  }\r\n\r\n  async getProcessedTokenData(): Promise<ProcessedTokenData> {\r\n    return {\r\n      security: await this.fetchTokenSecurity(),\r\n      tradeData: await this.fetchTokenTradeData(),\r\n      holderDistributionTrend: await this.analyzeHolderDistribution(),\r\n      highValueHolders: await this.filterHighValueHolders(),\r\n      recentTrades: await this.checkRecentTrades(),\r\n      dexScreenerData: await this.fetchDexScreenerData(),\r\n    };\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"swap-execution",children:"Swap Execution"}),"\n",(0,a.jsx)(e.p,{children:"Implementation of token swaps using Jupiter:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async function swapToken(\r\n  connection: Connection,\r\n  walletPublicKey: PublicKey,\r\n  inputTokenCA: string,\r\n  outputTokenCA: string,\r\n  amount: number,\r\n): Promise<any> {\r\n  // Get token decimals\r\n  const decimals = await getTokenDecimals(connection, inputTokenCA);\r\n  const adjustedAmount = amount * 10 ** decimals;\r\n\r\n  // Fetch quote\r\n  const quoteResponse = await fetch(\r\n    `https://quote-api.jup.ag/v6/quote?inputMint=${inputTokenCA}` +\r\n      `&outputMint=${outputTokenCA}` +\r\n      `&amount=${adjustedAmount}` +\r\n      `&slippageBps=50`,\r\n  );\r\n\r\n  // Execute swap\r\n  const swapResponse = await fetch("https://quote-api.jup.ag/v6/swap", {\r\n    method: "POST",\r\n    body: JSON.stringify({\r\n      quoteResponse: await quoteResponse.json(),\r\n      userPublicKey: walletPublicKey.toString(),\r\n      wrapAndUnwrapSol: true,\r\n    }),\r\n  });\r\n\r\n  return swapResponse.json();\r\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"position-management",children:"Position Management"}),"\n",(0,a.jsx)(e.h3,{id:"order-book-system",children:"Order Book System"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface Order {\r\n  userId: string;\r\n  ticker: string;\r\n  contractAddress: string;\r\n  timestamp: string;\r\n  buyAmount: number;\r\n  price: number;\r\n}\r\n\r\nclass OrderBookProvider {\r\n  async addOrder(order: Order): Promise<void> {\r\n    let orderBook = await this.readOrderBook();\r\n    orderBook.push(order);\r\n    await this.writeOrderBook(orderBook);\r\n  }\r\n\r\n  async calculateProfitLoss(userId: string): Promise<number> {\r\n    const orders = await this.getUserOrders(userId);\r\n    return orders.reduce((total, order) => {\r\n      const currentPrice = this.getCurrentPrice(order.ticker);\r\n      const pl = (currentPrice - order.price) * order.buyAmount;\r\n      return total + pl;\r\n    }, 0);\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"position-sizing",children:"Position Sizing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async function calculatePositionSize(\r\n  tokenData: ProcessedTokenData,\r\n  riskLevel: "LOW" | "MEDIUM" | "HIGH",\r\n): Promise<CalculatedBuyAmounts> {\r\n  const { liquidity, marketCap } = tokenData.dexScreenerData.pairs[0];\r\n\r\n  // Impact percentages based on liquidity\r\n  const impactPercentages = {\r\n    LOW: 0.01, // 1% of liquidity\r\n    MEDIUM: 0.05, // 5% of liquidity\r\n    HIGH: 0.1, // 10% of liquidity\r\n  };\r\n\r\n  return {\r\n    none: 0,\r\n    low: liquidity.usd * impactPercentages.LOW,\r\n    medium: liquidity.usd * impactPercentages.MEDIUM,\r\n    high: liquidity.usd * impactPercentages.HIGH,\r\n  };\r\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"risk-management",children:"Risk Management"}),"\n",(0,a.jsx)(e.h3,{id:"token-validation",children:"Token Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async function validateToken(token: TokenPerformance): Promise<boolean> {\r\n  const security = await fetchTokenSecurity(token.tokenAddress);\r\n\r\n  // Red flags check\r\n  if (\r\n    security.rugPull ||\r\n    security.isScam ||\r\n    token.rapidDump ||\r\n    token.suspiciousVolume ||\r\n    token.liquidity.usd < 1000 || // Minimum $1000 liquidity\r\n    token.marketCap < 100000 // Minimum $100k market cap\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  // Holder distribution check\r\n  const holderData = await fetchHolderList(token.tokenAddress);\r\n  const topHolderPercent = calculateTopHolderPercentage(holderData);\r\n  if (topHolderPercent > 0.5) {\r\n    // >50% held by top holders\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"trade-management",children:"Trade Management"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface TradeManager {\r\n    async executeTrade(params: {\r\n        inputToken: string,\r\n        outputToken: string,\r\n        amount: number,\r\n        slippage: number\r\n    }): Promise<string>;\r\n\r\n    async monitorPosition(params: {\r\n        tokenAddress: string,\r\n        entryPrice: number,\r\n        stopLoss: number,\r\n        takeProfit: number\r\n    }): Promise<void>;\r\n\r\n    async closePosition(params: {\r\n        tokenAddress: string,\r\n        amount: number\r\n    }): Promise<string>;\r\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"market-analysis",children:"Market Analysis"}),"\n",(0,a.jsx)(e.h3,{id:"price-data-collection",children:"Price Data Collection"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async function collectMarketData(\r\n  tokenAddress: string,\r\n): Promise<TokenTradeData> {\r\n  return {\r\n    price: await fetchCurrentPrice(tokenAddress),\r\n    volume_24h: await fetch24HourVolume(tokenAddress),\r\n    price_change_24h: await fetch24HourPriceChange(tokenAddress),\r\n    liquidity: await fetchLiquidity(tokenAddress),\r\n    holder_data: await fetchHolderData(tokenAddress),\r\n    trade_history: await fetchTradeHistory(tokenAddress),\r\n  };\r\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"technical-analysis",children:"Technical Analysis"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"function analyzeMarketConditions(tradeData: TokenTradeData): MarketAnalysis {\r\n  return {\r\n    trend: analyzePriceTrend(tradeData.price_history),\r\n    volume_profile: analyzeVolumeProfile(tradeData.volume_history),\r\n    liquidity_depth: analyzeLiquidityDepth(tradeData.liquidity),\r\n    holder_behavior: analyzeHolderBehavior(tradeData.holder_data),\r\n  };\r\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"trade-execution",children:"Trade Execution"}),"\n",(0,a.jsx)(e.h3,{id:"swap-implementation",children:"Swap Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async function executeSwap(\r\n  runtime: IAgentRuntime,\r\n  input: {\r\n    tokenIn: string;\r\n    tokenOut: string;\r\n    amountIn: number;\r\n    slippage: number;\r\n  },\r\n): Promise<string> {\r\n  // Prepare transaction\r\n  const { swapTransaction } = await getSwapTransaction(input);\r\n\r\n  // Sign transaction\r\n  const keypair = getKeypairFromPrivateKey(\r\n    runtime.getSetting("SOLANA_PRIVATE_KEY") ??\r\n      runtime.getSetting("WALLET_PRIVATE_KEY"),\r\n  );\r\n  transaction.sign([keypair]);\r\n\r\n  // Execute swap\r\n  const signature = await connection.sendTransaction(transaction);\r\n\r\n  // Confirm transaction\r\n  await connection.confirmTransaction({\r\n    signature,\r\n    blockhash: latestBlockhash.blockhash,\r\n    lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,\r\n  });\r\n\r\n  return signature;\r\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"dao-integration",children:"DAO Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async function executeSwapForDAO(\r\n  runtime: IAgentRuntime,\r\n  params: {\r\n    inputToken: string;\r\n    outputToken: string;\r\n    amount: number;\r\n  },\r\n): Promise<string> {\r\n  const authority = getAuthorityKeypair(runtime);\r\n  const [statePDA, walletPDA] = await derivePDAs(authority);\r\n\r\n  // Prepare instruction data\r\n  const instructionData = prepareSwapInstruction(params);\r\n\r\n  // Execute swap through DAO\r\n  return invokeSwapDao(\r\n    connection,\r\n    authority,\r\n    statePDA,\r\n    walletPDA,\r\n    instructionData,\r\n  );\r\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"monitoring--safety",children:"Monitoring & Safety"}),"\n",(0,a.jsx)(e.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async function performHealthChecks(): Promise<HealthStatus> {\r\n  return {\r\n    connection: await checkConnectionStatus(),\r\n    wallet: await checkWalletBalance(),\r\n    orders: await checkOpenOrders(),\r\n    positions: await checkPositions(),\r\n  };\r\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"safety-limits",children:"Safety Limits"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"const SAFETY_LIMITS = {\r\n  MAX_POSITION_SIZE: 0.1, // 10% of portfolio\r\n  MAX_SLIPPAGE: 0.05, // 5% slippage\r\n  MIN_LIQUIDITY: 1000, // $1000 minimum liquidity\r\n  MAX_PRICE_IMPACT: 0.03, // 3% price impact\r\n  STOP_LOSS: 0.15, // 15% stop loss\r\n};\n"})}),"\n",(0,a.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(e.h3,{id:"transaction-errors",children:"Transaction Errors"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:'async function handleTransactionError(\r\n  error: Error,\r\n  transaction: Transaction,\r\n): Promise<void> {\r\n  if (error.message.includes("insufficient funds")) {\r\n    await handleInsufficientFunds();\r\n  } else if (error.message.includes("slippage tolerance exceeded")) {\r\n    await handleSlippageError(transaction);\r\n  } else {\r\n    await logTransactionError(error, transaction);\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"recovery-procedures",children:"Recovery Procedures"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async function recoverFromError(\r\n  error: Error,\r\n  context: TradingContext,\r\n): Promise<void> {\r\n  // Stop all active trades\r\n  await stopActiveTrades();\r\n\r\n  // Close risky positions\r\n  await closeRiskyPositions();\r\n\r\n  // Reset system state\r\n  await resetTradingState();\r\n\r\n  // Notify administrators\r\n  await notifyAdministrators(error, context);\r\n}\n"})})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(l,{...n})}):l(n)}},28453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>s});var t=r(96540);const a={},i=t.createContext(a);function o(n){const e=t.useContext(i);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);